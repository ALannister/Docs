作者：知乎用户
链接：https://www.zhihu.com/question/23408154/answer/24699056
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

32位软件和64位最大区别,也是当年64位系统被推上舞台的原因是内存地址总线的问题.32位软件无法使用大于4G的内存,为什么? 32位系统上,这个地址是2^32次方个. 差不多就是4G. 所以32位系统单个软件能调用的最大内存是4G. 很多人觉得"什么大软件能用4G"内存? 有这种疑惑的人一般来说没用过专业软件,视频软件,音频软件,科学计算软件这类专业软件对内存的需求量超大,像编曲的候,一个cubase软件占10来个G内存真不叫事. 所以说,x64架构的最大优势就是内存地址总线是2^64次方(目前是2^48个),足够用了! 实际上现在很多游戏已经对内存的需求也远超4G了,刚才玩星际2,4v4打后期32位星际进程直接崩溃了. 
然后,64位cpu当然还有个优势就是寄存器的变成64位了,以前32位cpu处理一次64位整形加法需要至少4个寄存器,现在用两个就够了.事实上intel的x64体系,在所有寄存器变为64位的基础上,由增加了8个全新的64位通用寄存器,而且每个寄存器能拆分成2个32位寄存器,相当于x64体系比x86增加了4倍的32位寄存器数量. 这种优势是相当大的.
寄存器多了有什么好处? 一般来说是对速度有一定帮助,例如x86中我们能用的寄存器只有6个,但有时候写程序变量不可能只有6个,可能有,比如10个,这时剩下没法加载到寄存器中的4个变量就要不断地在寄存器和内存地址之间交互,如果在一个大循环中有这种内存-寄存器之间不断地交互,是很影响速度的.而x64,我们拥有20来个寄存器可以用,我们可以在循环之前将所有变量存入寄存器,然后循环中不在有寄存器与栈空间之间的交互. 可以提升速度.
再然后还有扩展的AVX寄存器,比SSE寄存器长了一倍.对计算量很大的应用来说,是非常非常有效 的.比如游戏,视频音频编码,解压缩之类的.
然后,是你的问题,即"x86移植x64的bug"问题. 我拿C语言来说吧, C语言是平台无关的语言,理论上,任何纯C语言写的代码只要你没调用本地接口,都应该能够毫无压力地编译到x64上,但是,大多数程序员都爱写及其平台依赖的代码,最最最最典型的例子就是 比如 float* p; int a=(int)p; 只要你的代码中出现一个这样的问题,就会导致整个程序在x64上崩溃,因为int类型在x64平台上是4byte,而float*指针的尺寸在x64上是8byte. C语言一再强调不要假设int类型变量的尺寸,不要假设指针的尺寸,就是为了最大的兼容各种平台,正确的写法是 uintptr_t a=(uintptr_t)p; uintptr_t是标准规定的任何时候都与指针尺寸一样长的整型. 这个类型很多人连听都没听说过. 这类细节问题,还有其他各种问题导致了移植x64的困难. 
然后,64位编译器可以编译32位代码,32位编译器也可以编译64位代码.理论上甚至ARM处理器上的编译器也可以编译x86目标 编译器只是把你写的C代码变成目标平台的汇编码,至于这个汇编cpu能不能认,那不是编译器管的事.
接下来,看起来intel似乎想推广x128处理器,按照规律应该会出现1024位的SIMD寄存器,一条指令计算16个float,真是想想都觉得幸福啊....